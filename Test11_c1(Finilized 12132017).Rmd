---
title: "IMU+ML"
author: "Junqi Zhao"
date: "11/4/2017"
output:
  word_document: default
  html_document: default
---


#Test11_c1
##Load Train Dataset C1
```{r}
#load data
setwd("D:/Academic/Human Posture Quatification/DataDriven/IMU-ML/Testing Data/Test 11_five sensor/c1")
th_ac=read.csv(file = "Thigh-2017-12-07T15.53.49.621-E9EC8E26570F-Accelerometer.csv",header = T)
th_gy=read.csv(file = "Thigh-2017-12-07T15.53.49.621-E9EC8E26570F-Gyroscope.csv",header = T)
cr_ac=read.csv(file = "Calf-2017-12-07T15.53.49.674-DF65B51A61E1-Accelerometer.csv",header = T)
cr_gy=read.csv(file = "Calf-2017-12-07T15.53.49.674-DF65B51A61E1-Gyroscope.csv",header = T)
ch_ac=read.csv(file = "Chest-2017-12-07T15.53.49.659-CC545A35F289-Accelerometer.csv",header = T)
ch_gy=read.csv(file = "Chest-2017-12-07T15.53.49.659-CC545A35F289-Gyroscope.csv",header = T)
#check length
last=floor(tail(th_ac$elapsed..s., n=1))
len=nrow(subset.data.frame(th_ac,th_ac$elapsed..s.>1&th_ac$elapsed..s.<last))
#extract uniform lendth data from multiple datasets
th_ac=subset.data.frame(th_ac,th_ac$elapsed..s.>1)[1:len,3:6]
th_gy=subset.data.frame(th_gy,th_gy$elapsed..s.>1)[1:len,4:6]
cr_ac=subset.data.frame(cr_ac,cr_ac$elapsed..s.>1)[1:len,4:6]
cr_gy=subset.data.frame(cr_gy,cr_gy$elapsed..s.>1)[1:len,4:6]
ch_ac=subset.data.frame(ch_ac,ch_ac$elapsed..s.>1)[1:len,4:6]
ch_gy=subset.data.frame(ch_gy,ch_gy$elapsed..s.>1)[1:len,4:6]
#combine columns into a new dataframe t1
t=cbind(index=c(1:len),th_ac[,1],th_ac[,-1],th_gy,cr_ac,cr_gy,ch_ac,ch_gy,label=c(1:len))
#rename columns
test=data.frame(index=t[,1],elapsed=t[,2],th_acc_x=t[,3],th_acc_y=t[,4],th_acc_z=t[,5],th_gy_x=t[,6],th_gy_y=t[,7],th_gy_z=t[,8],cr_ac_x=t[,9],cr_ac_y=t[,10],cr_ac_z=t[,11],cr_gy_x=t[,12],cr_gy_y=t[,13],cr_gy_z=t[,14],ch_ac_x=t[,15],ch_ac_y=t[,16],ch_ac_z=t[,17],ch_gy_x=t[,18],ch_gy_y=t[,19],ch_gy_z=t[,20],label=t[,21])
#export dataframe for labeling
write.csv(test, "Test11-c1.csv")
rm(list = ls()) #clear work space

```

##Stage 0 Global classifier with varying window size
###Seaerching the optimal window size
```{r}
#import the labelled data
Test11_c1=read.csv(file = "Test11_c1_label_nowkwkss.csv",header = T)
##Data Segmentation Preparation
imudata=Test11_c1 #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,22:24]=NA #create three empty columns
colnames(imudata)[22:24]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
library('clusterSim')
library("e1071")
library("caret")
library("rpart")
#define the storage space for window size performance
win_t=rep(0,21)
win_size=win_t
nbtime=win_t
nbacc=win_t
nbkappa=win_t
nbtime_training=win_t
svmtime=win_t
svmacc=win_t
svmkappa=win_t
svmtime_training=win_t
knntime=win_t
knnacc=win_t
knnkappa=win_t
knntime_training=win_t
treetime=win_t
treeacc=win_t
treekappa=win_t
treetime_training=win_t
##Tesing different window size
for (ii in 0:21){ 
if(ii==5) next
#set up parameters with regard to the data collection condition
t=0.4+0.1*ii #setting window size as t seconds (fixed)
win_t[ii+1]=t #storing the window size
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x

#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
win_size[ii+1]=n
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)
#replace with bestset from feature selection
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_y, rms_cr_acc_x, mean_cr_acc_x, mean_cr_acc_z, mean_cr_acc_y, rms_cr_acc_z, mean_ch_acc_z, max_cr_acc_z, max_cr_acc_x, max_ch_acc_z, min_ch_acc_z, rms_ch_acc_z, mean_ch_acc_x, rms_ch_acc_x, max_cr_acc_y, min_cr_acc_x, max_th_acc_z, min_cr_acc_y, min_cr_acc_z, entr_cr_acc_z, frp_cr_acc_z, aad_cr_acc_x, rms_cr_gy_y, var_cr_acc_z, aad_cr_acc_z, mean_th_acc_z, min_ch_acc_x, cen_cr_acc_z, eng_cr_acc_z, min_cr_gy_z, slope_ch_gy_y, skew_cr_acc_z, rms_th_acc_z, var_cr_gy_y, aad_cr_gy_y, max_cr_gy_z, var_cr_acc_x, mean_cr_gy_z, frp_cr_acc_x, rms_th_acc_x, min_th_acc_z, slope_cr_acc_x, mean_ch_gy_y, mean_cr_gy_y, cen_ch_acc_z, mean_th_acc_x, aad_cr_gy_z, rms_cr_gy_z, kur_cr_acc_z, slope_ch_acc_z, max_cr_gy_y, aad_cr_acc_y, var_cr_gy_z, entr_cr_acc_x, slope_cr_acc_z, entr_ch_acc_z, var_cr_acc_y, cen_cr_acc_x, aad_ch_acc_z, min_cr_gy_y, slope_cr_acc_y, min_th_acc_y, rms_ch_gy_y, var_ch_acc_z, frp_cr_acc_y, max_ch_acc_x, max_th_acc_x, frp_th_acc_z, entr_cr_acc_y, mean_th_gy_y, var_th_gy_z, rms_cr_gy_x, min_th_gy_y, rms_th_gy_z, entr_th_acc_z, cen_cr_acc_y, aad_cr_gy_x, cen_th_acc_z, slope_ch_acc_x, var_cr_gy_x, aad_ch_acc_x, frp_ch_acc_z, max_th_gy_y, rms_ch_acc_y, min_th_acc_x, var_th_acc_y, max_th_gy_x, entr_cr_gy_y, rms_ch_gy_x, max_th_gy_z, max_th_acc_y, slope_th_acc_z, min_ch_gy_x, var_th_gy_x, min_th_gy_x, rms_ch_gy_z, mean_th_acc_y, var_ch_acc_x, var_ch_gy_x, var_ch_gy_y, max_ch_gy_y, eng_th_acc_y, min_ch_gy_y, aad_ch_gy_y, min_th_gy_z, var_th_gy_y, eng_th_acc_z, aad_th_gy_y, cen_cr_gy_y, var_ch_gy_z, eng_cr_acc_x, frp_cr_gy_y, min_cr_gy_x, frp_th_acc_y, kur_th_acc_z, rms_th_gy_y, eng_ch_acc_z, var_ch_acc_y, skew_th_acc_z, rms_th_gy_x, max_ch_acc_y, eng_cr_acc_y, kur_th_acc_y, aad_th_gy_z, var_th_acc_x, entr_cr_gy_z, cen_cr_gy_z, entr_th_acc_y, cen_ch_gy_y, frp_th_acc_x)
#Data Normilization

c=ncol(mydata)
features=mydata[,3:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]

#Machine Learning
## Data preparation
c=ncol(mydata)
mydata3=mydata[,2:c] #deleted the window index
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata3$label,p=0.8, list = FALSE)
mydata3.training=mydata3[index,]
mydata3.testing=mydata3[-index,]
###Naive Bayes
nbmodel=naiveBayes(label~., data=mydata3.training)
nbtime_training[ii+1]=system.time(naiveBayes(label~., data=mydata3.training))
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(nbmodel, mydata3.testing,type="class")
nbtime[ii+1]=system.time(p<- predict(nbmodel, mydata3.testing,type="class"))
nbconf.matrix=confusionMatrix(p, mydata3.testing$label)
nbacc[ii+1]=nbconf.matrix$overall[1]
nbkappa[ii+1]=nbconf.matrix$overall[2]

###SVM
#no tuning
svmmodel=svm(label~., data=mydata3)
svmtime_training[ii+1]=system.time(svm(label~., data=mydata3))


#svm_tune=tune(svm,label~., data=mydata3,ranges = list(epsilon = seq(0,1,0.5)))
#svmmodel=svm_tune$best.model
#svmtime_training[ii+1]=system.time(tune(svm,label~., data=mydata3,ranges = list(epsilon = seq(0,1,0.5))))
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(svmmodel, mydata3.testing,type="class")
svmtime[ii+1]=system.time(p<- predict(svmmodel, mydata3.testing,type="class"))
svmconf.matrix=confusionMatrix(p, mydata3.testing$label)
svmacc[ii+1]=svmconf.matrix$overall[1]
svmkappa[ii+1]=svmconf.matrix$overall[2]

###MDA
#train the model
#set.seed(9)
#train_control2 <- trainControl(method="cv") #conduct the cross validation
#mdagrid=expand.grid(subclasses=c(1:10))
#mdamodel <- train(label~.,data=mydata3.training, trControl=train_control2, method="mda",tuneGrid=mdagrid)
#mdatime_training[ii+1]=system.time(train(label~.,data=mydata3.training, trControl=train_control2, method="mda",tuneGrid=mdagrid))
#check the model performance
#mdatime[ii+1]=system.time(p=predict(mdamodel, mydata3.testing))
#mdaconf.matrix=confusionMatrix(mydata3.testing$label, predict(mdamodel, mydata3.testing))
#mdaacc[ii+1]=mdaconf.matrix$overall[1]

###KNN clustering
#load data
mydata=transform(mydata,label=as.factor(as.character(mydata$label))) #Transform class into factor for classification
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata$label,p=0.8, list = FALSE)
mydata.training=mydata[index,]
mydata.testing=mydata[-index,]
#train the model
trctrl=trainControl(method="cv")
set.seed(9)
grid=expand.grid(k=c(1:20))
set.seed(9)
c=ncol(mydata)
model.knn=train(mydata.training[, 3:c], mydata.training[, 2], method='knn',trControl=trctrl,tuneGrid = grid,tuneLength = 1)
knntime_training[ii+1]=system.time(train(mydata.training[, 3:c], mydata.training[, 2], method='knn',trControl=trctrl,tuneGrid = grid,tuneLength = 1))
#Evaluate the model
#inspect the performance of training set
#model.knn
#plot(model.knn)
#inspect the performance of testing set
set.seed(9)
predictions=predict(object = model.knn,mydata.testing[,3:c])
#table(predictions)
knnconf.matrix=confusionMatrix(predictions,mydata.testing[,2])
knntime[ii+1]=system.time(p<- predict(object = model.knn,mydata.testing[,3:c]))
knnacc[ii+1]=knnconf.matrix$overall[1]
knnkappa[ii+1]=knnconf.matrix$overall[2]

###Decision Tree
#Splitting the Data
mydata2=mydata[,2:c] #deleted the window index
mydata2=transform(mydata2,label=as.factor(as.character(mydata2$label))) #Transform class into factor for classification
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata2$label,p=0.8, list = FALSE)
mydata2.training=mydata2[index,]
mydata2.testing=mydata2[-index,]
#Build a Decision Tree with the stopping creteria of small decreasing of lack of fit
set.seed(123)
tree=rpart(label~.,data=mydata2.training, control=rpart.control(xval =10))
treetime_training[ii+1]=system.time(rpart(label~.,data=mydata2.training, control=rpart.control(xval =10)))
#Choose the tree size which minimizes misclassification rate
#printcp(tree) #the parameter cp is complexity number, any split that does not decrease the overall lack of fit by a factor of cp is not attampted.
#Select the best cp value based on the minimum cross-validation error
bestcp=tree$cptable[which.min(tree$cptable[,"xerror"]),"CP"]
#Prune the tree based on best CP value
tree.pruned=prune(tree,cp=bestcp)
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(tree, mydata2.testing,type="class")
treeconf.matrix=confusionMatrix(p, mydata2.testing$label)
treetime[ii+1]=system.time(p<- predict(tree, mydata2.testing,type="class"))
treeacc[ii+1]=treeconf.matrix$overall[1]
treekappa[ii+1]=treeconf.matrix$overall[2]
  }
globalmodeleva=data.frame(win_t,nbtime_training,nbtime,nbacc,nbkappa,svmtime_training,svmtime,svmacc,svmkappa,knntime_training,knntime,knnacc,knnkappa,treetime_training,treetime,treeacc,treekappa)
#output the result
setwd("D:/Academic/Human Posture Quatification/DataDriven/IMU-ML/Testing Data/Test 11_five sensor/c1")
write.csv(globalmodeleva,"Globalmodeleva(0.5-2.5)+kappa+nosvmtuning.csv")
```

##Stage 1 Classifier 1 with varying window size
##Data segmentation
```{r}
#import the labelled data
Test11_c1=read.csv(file = "Test11_c1_label_nowkwkss_C1.csv",header = T)
##Data Segmentation Preparation
imudata=Test11_c1 #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,22:24]=NA #create three empty columns
colnames(imudata)[22:24]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
library('clusterSim')
library("e1071")
library("caret")
library("rpart")
#define the storage space for window size performance
win_t=rep(0,11)
nbtime=win_t
nbacc=win_t
nbtime_training=win_t
nbacc_training=win_t
svmtime=win_t
svmacc=win_t
svmtime_training=win_t
knntime=win_t
knnacc=win_t
knntime_training=win_t
treetime=win_t
treeacc=win_t
treetime_training=win_t
```

```{r}
##Tesing different window size
for (ii in 6:16){
#set up parameters with regard to the data collection condition
t=0.4+0.1*ii #setting window size as t seconds (fixed)
win_t[ii+1]=t #storing the window size
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x

#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)
#replace with bestset from feature selection
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_y, rms_cr_acc_x, mean_cr_acc_x, mean_cr_acc_z, mean_cr_acc_y, rms_cr_acc_z, mean_ch_acc_z, max_cr_acc_z, max_cr_acc_x, max_ch_acc_z, min_ch_acc_z, rms_ch_acc_z, mean_ch_acc_x, rms_ch_acc_x, max_cr_acc_y, min_cr_acc_x, max_th_acc_z, min_cr_acc_y, min_cr_acc_z, entr_cr_acc_z, frp_cr_acc_z, aad_cr_acc_x, rms_cr_gy_y, var_cr_acc_z, aad_cr_acc_z, mean_th_acc_z, min_ch_acc_x, cen_cr_acc_z, eng_cr_acc_z, min_cr_gy_z, slope_ch_gy_y, skew_cr_acc_z, rms_th_acc_z, var_cr_gy_y, aad_cr_gy_y, max_cr_gy_z, var_cr_acc_x, mean_cr_gy_z, frp_cr_acc_x, rms_th_acc_x, min_th_acc_z, slope_cr_acc_x, mean_ch_gy_y, mean_cr_gy_y, cen_ch_acc_z, mean_th_acc_x, aad_cr_gy_z, rms_cr_gy_z, kur_cr_acc_z, slope_ch_acc_z, max_cr_gy_y, aad_cr_acc_y, var_cr_gy_z, entr_cr_acc_x, slope_cr_acc_z, entr_ch_acc_z, var_cr_acc_y, cen_cr_acc_x, aad_ch_acc_z, min_cr_gy_y, slope_cr_acc_y, min_th_acc_y, rms_ch_gy_y, var_ch_acc_z, frp_cr_acc_y, max_ch_acc_x, max_th_acc_x, frp_th_acc_z, entr_cr_acc_y, mean_th_gy_y, var_th_gy_z, rms_cr_gy_x, min_th_gy_y, rms_th_gy_z, entr_th_acc_z, cen_cr_acc_y, aad_cr_gy_x, cen_th_acc_z, slope_ch_acc_x, var_cr_gy_x, aad_ch_acc_x, frp_ch_acc_z, max_th_gy_y, rms_ch_acc_y, min_th_acc_x, var_th_acc_y, max_th_gy_x, entr_cr_gy_y, rms_ch_gy_x, max_th_gy_z, max_th_acc_y, slope_th_acc_z, min_ch_gy_x, var_th_gy_x, min_th_gy_x, rms_ch_gy_z, mean_th_acc_y, var_ch_acc_x, var_ch_gy_x, var_ch_gy_y, max_ch_gy_y, eng_th_acc_y, min_ch_gy_y, aad_ch_gy_y, min_th_gy_z, var_th_gy_y, eng_th_acc_z, aad_th_gy_y, cen_cr_gy_y, var_ch_gy_z, eng_cr_acc_x, frp_cr_gy_y, min_cr_gy_x, frp_th_acc_y, kur_th_acc_z, rms_th_gy_y, eng_ch_acc_z, var_ch_acc_y, skew_th_acc_z, rms_th_gy_x, max_ch_acc_y, eng_cr_acc_y, kur_th_acc_y, aad_th_gy_z, var_th_acc_x, entr_cr_gy_z, cen_cr_gy_z, entr_th_acc_y, cen_ch_gy_y, frp_th_acc_x)
#Data Normilization

c=ncol(mydata)
features=mydata[,3:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]

#Machine Learning
## Data preparation
c=ncol(mydata)
mydata3=mydata[,2:c] #deleted the window index
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata3$label,p=0.8, list = FALSE)
mydata3.training=mydata3[index,]
mydata3.testing=mydata3[-index,]
###Naive Bayes
nbmodel=naiveBayes(label~., data=mydata3.training)
nbtime_training[ii+1]=system.time(naiveBayes(label~., data=mydata3.training))
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(nbmodel, mydata3.testing,type="class")
nbtime[ii+1]=system.time(p<- predict(nbmodel, mydata3.testing,type="class"))
nbconf.matrix=confusionMatrix(p, mydata3.testing$label)
nbacc[ii+1]=nbconf.matrix$overall[1]

###SVM
svmmodel=svm(label~., data=mydata3.training)
svmtime_training[ii+1]=system.time(svm(label~., data=mydata3.training))
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(svmmodel, mydata3.testing,type="class")
svmtime[ii+1]=system.time(p<- predict(svmmodel, mydata3.testing,type="class"))
svmconf.matrix=confusionMatrix(p, mydata3.testing$label)
svmacc[ii+1]=svmconf.matrix$overall[1]


###MDA
#train the model
#set.seed(9)
#train_control2 <- trainControl(method="cv") #conduct the cross validation
#mdagrid=expand.grid(subclasses=c(1:10))
#mdamodel <- train(label~.,data=mydata3.training, trControl=train_control2, method="mda",tuneGrid=mdagrid)
#mdatime_training[ii+1]=system.time(train(label~.,data=mydata3.training, trControl=train_control2, method="mda",tuneGrid=mdagrid))
#check the model performance
#mdatime[ii+1]=system.time(p=predict(mdamodel, mydata3.testing))
#mdaconf.matrix=confusionMatrix(mydata3.testing$label, predict(mdamodel, mydata3.testing))
#mdaacc[ii+1]=mdaconf.matrix$overall[1]

###KNN clustering
#load data
mydata=transform(mydata,label=as.factor(as.character(mydata$label))) #Transform class into factor for classification
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata$label,p=0.8, list = FALSE)
mydata.training=mydata[index,]
mydata.testing=mydata[-index,]
#train the model
trctrl=trainControl(method="repeatedcv", number=10,repeats = 10)
set.seed(9)
grid=expand.grid(k=c(1:20))
set.seed(9)
c=ncol(mydata)
model.knn=train(mydata.training[, 3:c], mydata.training[, 2], method='knn',trControl=trctrl,tuneGrid = grid,tuneLength = 1)
knntime_training[ii+1]=system.time(train(mydata.training[, 3:c], mydata.training[, 2], method='knn',trControl=trctrl,tuneGrid = grid,tuneLength = 1))
#Evaluate the model
#inspect the performance of training set
#model.knn
#plot(model.knn)
#inspect the performance of testing set
set.seed(9)
predictions=predict(object = model.knn,mydata.testing[,3:c])
#table(predictions)
knnconf.matrix=confusionMatrix(predictions,mydata.testing[,2])
knntime[ii+1]=system.time(p<- predict(object = model.knn,mydata.testing[,3:c]))
knnacc[ii+1]=knnconf.matrix$overall[1]


###Decision Tree
#Splitting the Data
mydata2=mydata[,2:c] #deleted the window index
mydata2=transform(mydata2,label=as.factor(as.character(mydata2$label))) #Transform class into factor for classification
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata2$label,p=0.8, list = FALSE)
mydata2.training=mydata2[index,]
mydata2.testing=mydata2[-index,]
#Build a Decision Tree with the stopping creteria of small decreasing of lack of fit
set.seed(123)
tree=rpart(label~.,data=mydata2.training, control=rpart.control(xval =10))
treetime_training[ii+1]=system.time(rpart(label~.,data=mydata2.training, control=rpart.control(xval =10)))
#Choose the tree size which minimizes misclassification rate
#printcp(tree) #the parameter cp is complexity number, any split that does not decrease the overall lack of fit by a factor of cp is not attampted.
#Select the best cp value based on the minimum cross-validation error
bestcp=tree$cptable[which.min(tree$cptable[,"xerror"]),"CP"]
#Prune the tree based on best CP value
tree.pruned=prune(tree,cp=bestcp)
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(tree, mydata2.testing,type="class")
treeconf.matrix=confusionMatrix(p, mydata2.testing$label)
treetime[ii+1]=system.time(p<- predict(tree, mydata2.testing,type="class"))
treeacc[ii+1]=treeconf.matrix$overall[1]
}
c1modeleva=data.frame(win_t,nbtime_training,nbtime,nbacc,svmtime_training,svmtime,svmacc,knntime_training,knntime,knnacc,treetime_training,treetime,treeacc)
```

##Stage 2 Classifier 2 with varying window size
##Data segmentation
```{r}
#import the labelled data
Test11_c2=read.csv(file = "Test11_c1_label_nowkwkss_C2.csv",header = T)
##Data Segmentation Preparation
imudata=Test11_c2 #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,22:24]=NA #create three empty columns
colnames(imudata)[22:24]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
library('clusterSim')
library("e1071")
library("caret")
library("rpart")
#define the storage space for window size performance
win_t=rep(0,11)
nbtime=win_t
nbacc=win_t
nbtime_training=win_t
nbacc_training=win_t
svmtime=win_t
svmacc=win_t
svmtime_training=win_t
knntime=win_t
knnacc=win_t
knntime_training=win_t
treetime=win_t
treeacc=win_t
treetime_training=win_t
```

```{r}
##Tesing different window size
for (ii in 6:16){
#set up parameters with regard to the data collection condition
t=0.4+0.1*ii #setting window size as t seconds (fixed)
win_t[ii+1]=t #storing the window size
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x

#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)
#replace with bestset from feature selection
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_y, rms_cr_acc_x, mean_cr_acc_x, mean_cr_acc_z, mean_cr_acc_y, rms_cr_acc_z, mean_ch_acc_z, max_cr_acc_z, max_cr_acc_x, max_ch_acc_z, min_ch_acc_z, rms_ch_acc_z, mean_ch_acc_x, rms_ch_acc_x, max_cr_acc_y, min_cr_acc_x, max_th_acc_z, min_cr_acc_y, min_cr_acc_z, entr_cr_acc_z, frp_cr_acc_z, aad_cr_acc_x, rms_cr_gy_y, var_cr_acc_z, aad_cr_acc_z, mean_th_acc_z, min_ch_acc_x, cen_cr_acc_z, eng_cr_acc_z, min_cr_gy_z, slope_ch_gy_y, skew_cr_acc_z, rms_th_acc_z, var_cr_gy_y, aad_cr_gy_y, max_cr_gy_z, var_cr_acc_x, mean_cr_gy_z, frp_cr_acc_x, rms_th_acc_x, min_th_acc_z, slope_cr_acc_x, mean_ch_gy_y, mean_cr_gy_y, cen_ch_acc_z, mean_th_acc_x, aad_cr_gy_z, rms_cr_gy_z, kur_cr_acc_z, slope_ch_acc_z, max_cr_gy_y, aad_cr_acc_y, var_cr_gy_z, entr_cr_acc_x, slope_cr_acc_z, entr_ch_acc_z, var_cr_acc_y, cen_cr_acc_x, aad_ch_acc_z, min_cr_gy_y, slope_cr_acc_y, min_th_acc_y, rms_ch_gy_y, var_ch_acc_z, frp_cr_acc_y, max_ch_acc_x, max_th_acc_x, frp_th_acc_z, entr_cr_acc_y, mean_th_gy_y, var_th_gy_z, rms_cr_gy_x, min_th_gy_y, rms_th_gy_z, entr_th_acc_z, cen_cr_acc_y, aad_cr_gy_x, cen_th_acc_z, slope_ch_acc_x, var_cr_gy_x, aad_ch_acc_x, frp_ch_acc_z, max_th_gy_y, rms_ch_acc_y, min_th_acc_x, var_th_acc_y, max_th_gy_x, entr_cr_gy_y, rms_ch_gy_x, max_th_gy_z, max_th_acc_y, slope_th_acc_z, min_ch_gy_x, var_th_gy_x, min_th_gy_x, rms_ch_gy_z, mean_th_acc_y, var_ch_acc_x, var_ch_gy_x, var_ch_gy_y, max_ch_gy_y, eng_th_acc_y, min_ch_gy_y, aad_ch_gy_y, min_th_gy_z, var_th_gy_y, eng_th_acc_z, aad_th_gy_y, cen_cr_gy_y, var_ch_gy_z, eng_cr_acc_x, frp_cr_gy_y, min_cr_gy_x, frp_th_acc_y, kur_th_acc_z, rms_th_gy_y, eng_ch_acc_z, var_ch_acc_y, skew_th_acc_z, rms_th_gy_x, max_ch_acc_y, eng_cr_acc_y, kur_th_acc_y, aad_th_gy_z, var_th_acc_x, entr_cr_gy_z, cen_cr_gy_z, entr_th_acc_y, cen_ch_gy_y, frp_th_acc_x)
#Data Normilization

c=ncol(mydata)
features=mydata[,3:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]

#Machine Learning
## Data preparation
c=ncol(mydata)
mydata3=mydata[,2:c] #deleted the window index
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata3$label,p=0.8, list = FALSE)
mydata3.training=mydata3[index,]
mydata3.testing=mydata3[-index,]
###Naive Bayes
nbmodel=naiveBayes(label~., data=mydata3.training)
nbtime_training[ii+1]=system.time(naiveBayes(label~., data=mydata3.training))
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(nbmodel, mydata3.testing,type="class")
nbtime[ii+1]=system.time(p<- predict(nbmodel, mydata3.testing,type="class"))
nbconf.matrix=confusionMatrix(p, mydata3.testing$label)
nbacc[ii+1]=nbconf.matrix$overall[1]

###SVM
svmmodel=svm(label~., data=mydata3.training)
svmtime_training[ii+1]=system.time(svm(label~., data=mydata3.training))
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(svmmodel, mydata3.testing,type="class")
svmtime[ii+1]=system.time(p<- predict(svmmodel, mydata3.testing,type="class"))
svmconf.matrix=confusionMatrix(p, mydata3.testing$label)
svmacc[ii+1]=svmconf.matrix$overall[1]


###MDA
#train the model
#set.seed(9)
#train_control2 <- trainControl(method="cv") #conduct the cross validation
#mdagrid=expand.grid(subclasses=c(1:10))
#mdamodel <- train(label~.,data=mydata3.training, trControl=train_control2, method="mda",tuneGrid=mdagrid)
#mdatime_training[ii+1]=system.time(train(label~.,data=mydata3.training, trControl=train_control2, method="mda",tuneGrid=mdagrid))
#check the model performance
#mdatime[ii+1]=system.time(p=predict(mdamodel, mydata3.testing))
#mdaconf.matrix=confusionMatrix(mydata3.testing$label, predict(mdamodel, mydata3.testing))
#mdaacc[ii+1]=mdaconf.matrix$overall[1]

###KNN clustering
#load data
mydata=transform(mydata,label=as.factor(as.character(mydata$label))) #Transform class into factor for classification
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata$label,p=0.8, list = FALSE)
mydata.training=mydata[index,]
mydata.testing=mydata[-index,]
#train the model
trctrl=trainControl(method="repeatedcv", number=10,repeats = 10)
set.seed(9)
grid=expand.grid(k=c(1:20))
set.seed(9)
c=ncol(mydata)
model.knn=train(mydata.training[, 3:c], mydata.training[, 2], method='knn',trControl=trctrl,tuneGrid = grid,tuneLength = 1)
knntime_training[ii+1]=system.time(train(mydata.training[, 3:c], mydata.training[, 2], method='knn',trControl=trctrl,tuneGrid = grid,tuneLength = 1))
#Evaluate the model
#inspect the performance of training set
#model.knn
#plot(model.knn)
#inspect the performance of testing set
set.seed(9)
predictions=predict(object = model.knn,mydata.testing[,3:c])
#table(predictions)
knnconf.matrix=confusionMatrix(predictions,mydata.testing[,2])
knntime[ii+1]=system.time(p<- predict(object = model.knn,mydata.testing[,3:c]))
knnacc[ii+1]=knnconf.matrix$overall[1]


###Decision Tree
#Splitting the Data
mydata2=mydata[,2:c] #deleted the window index
mydata2=transform(mydata2,label=as.factor(as.character(mydata2$label))) #Transform class into factor for classification
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata2$label,p=0.8, list = FALSE)
mydata2.training=mydata2[index,]
mydata2.testing=mydata2[-index,]
#Build a Decision Tree with the stopping creteria of small decreasing of lack of fit
set.seed(123)
tree=rpart(label~.,data=mydata2.training, control=rpart.control(xval =10))
treetime_training[ii+1]=system.time(rpart(label~.,data=mydata2.training, control=rpart.control(xval =10)))
#Choose the tree size which minimizes misclassification rate
#printcp(tree) #the parameter cp is complexity number, any split that does not decrease the overall lack of fit by a factor of cp is not attampted.
#Select the best cp value based on the minimum cross-validation error
bestcp=tree$cptable[which.min(tree$cptable[,"xerror"]),"CP"]
#Prune the tree based on best CP value
tree.pruned=prune(tree,cp=bestcp)
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(tree, mydata2.testing,type="class")
treeconf.matrix=confusionMatrix(p, mydata2.testing$label)
treetime[ii+1]=system.time(p<- predict(tree, mydata2.testing,type="class"))
treeacc[ii+1]=treeconf.matrix$overall[1]
}
c2modeleva=data.frame(win_t,nbtime_training,nbtime,nbacc,svmtime_training,svmtime,svmacc,knntime_training,knntime,knnacc,treetime_training,treetime,treeacc)
```




#Train Specific Classifier
##Global Classifier
```{r}
setwd("D:/Academic/Human Posture Quatification/DataDriven/IMU-ML/Testing Data/Test 11_five sensor/c1")
Test=read.csv(file = "Test11_c1_label_nowkwkss.csv",header = T)
```
###Data Segmentation
```{r}
imudata=Test #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,22:24]=NA #create three empty columns
colnames(imudata)[22:24]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#set up parameters with regard to the data collection condition
t=1.2 #setting window size as t seconds (fixed)
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
```
###Feature Construction
```{r}
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)

#replace with bestset from feature selection
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_y, rms_cr_acc_x, mean_cr_acc_x, mean_cr_acc_z, mean_cr_acc_y, rms_cr_acc_z, mean_ch_acc_z, max_cr_acc_z, max_cr_acc_x, max_ch_acc_z, min_ch_acc_z, rms_ch_acc_z, mean_ch_acc_x, rms_ch_acc_x, max_cr_acc_y, min_cr_acc_x, max_th_acc_z, min_cr_acc_y, min_cr_acc_z, entr_cr_acc_z, frp_cr_acc_z, aad_cr_acc_x, rms_cr_gy_y, var_cr_acc_z, aad_cr_acc_z, mean_th_acc_z, min_ch_acc_x, cen_cr_acc_z, eng_cr_acc_z, min_cr_gy_z, slope_ch_gy_y, skew_cr_acc_z, rms_th_acc_z, var_cr_gy_y, aad_cr_gy_y, max_cr_gy_z, var_cr_acc_x, mean_cr_gy_z, frp_cr_acc_x, rms_th_acc_x, min_th_acc_z, slope_cr_acc_x, mean_ch_gy_y, mean_cr_gy_y, cen_ch_acc_z, mean_th_acc_x, aad_cr_gy_z, rms_cr_gy_z, kur_cr_acc_z, slope_ch_acc_z, max_cr_gy_y, aad_cr_acc_y, var_cr_gy_z, entr_cr_acc_x, slope_cr_acc_z, entr_ch_acc_z, var_cr_acc_y, cen_cr_acc_x, aad_ch_acc_z, min_cr_gy_y, slope_cr_acc_y, min_th_acc_y, rms_ch_gy_y, var_ch_acc_z, frp_cr_acc_y, max_ch_acc_x, max_th_acc_x, frp_th_acc_z, entr_cr_acc_y, mean_th_gy_y, var_th_gy_z, rms_cr_gy_x, min_th_gy_y, rms_th_gy_z, entr_th_acc_z, cen_cr_acc_y, aad_cr_gy_x, cen_th_acc_z, slope_ch_acc_x, var_cr_gy_x, aad_ch_acc_x, frp_ch_acc_z, max_th_gy_y, rms_ch_acc_y, min_th_acc_x, var_th_acc_y, max_th_gy_x, entr_cr_gy_y, rms_ch_gy_x, max_th_gy_z, max_th_acc_y, slope_th_acc_z, min_ch_gy_x, var_th_gy_x, min_th_gy_x, rms_ch_gy_z, mean_th_acc_y, var_ch_acc_x, var_ch_gy_x, var_ch_gy_y, max_ch_gy_y, eng_th_acc_y, min_ch_gy_y, aad_ch_gy_y, min_th_gy_z, var_th_gy_y, eng_th_acc_z, aad_th_gy_y, cen_cr_gy_y, var_ch_gy_z, eng_cr_acc_x, frp_cr_gy_y, min_cr_gy_x, frp_th_acc_y, kur_th_acc_z, rms_th_gy_y, eng_ch_acc_z, var_ch_acc_y, skew_th_acc_z, rms_th_gy_x, max_ch_acc_y, eng_cr_acc_y, kur_th_acc_y, aad_th_gy_z, var_th_acc_x, entr_cr_gy_z, cen_cr_gy_z, entr_th_acc_y, cen_ch_gy_y, frp_th_acc_x)
#Data Normilization

c=ncol(mydata)
features=mydata[,3:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]
```
###Train Optimal Global model on entire C1
```{r}
c=ncol(mydata)
mydata3=mydata[,2:c] #deleted the window index
#constructing the training and testing set by 80% to 20%
#set.seed(9)
#index=createDataPartition(mydata3$label,p=0.8, list = FALSE)
#mydata3.training=mydata3[index,]
#mydata3.testing=mydata3[-index,]
###SVM
####tuning model
#svm_tune=tune(svm,label~., data=mydata3,ranges = list(epsilon = seq(0,1,0.5)))
#globalsvm.trainingtime=system.time(tune(svm,label~., data=mydata3,ranges = list(epsilon = seq(0,1,0.5))))
#svmmodel=svm_tune$best.model
svmmodel=svm(label~., data=mydata3)
globalsvm.trainingtime=system.time(svm(label~., data=mydata3))
#svmtime_training=system.time(svm(label~., data=mydata3))
#Test performance of the trained model with Confusion Matrix
#set.seed(123)
#p<- predict(svmmodel, mydata3.testing,type="class")
#svmtime_classifying=system.time(p<- predict(svmmodel, mydata3.testing,type="class"))
#svmconf.matrix=confusionMatrix(p, mydata3.testing$label)
#svmacc=svmconf.matrix$overall[1]
```
###Segment the T1_1 test dataset with optimal window size
```{r}
setwd("D:/Academic/Human Posture Quatification/DataDriven/IMU-ML/Testing Data/Test 11_five sensor/t1/t1-1")
#load labelled data
Test=read.csv(file = "Test11-t1_1_label.csv",header = T)
```
```{r}
##Data Segmentation
imudata=Test #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,22:24]=NA #create three empty columns
colnames(imudata)[22:24]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#set up parameters with regard to the data collection condition
t=1.2 #setting window size as t seconds (fixed)
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
```
```{r}
##Feature Construction
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)
#replace with bestset from feature selection
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_y, rms_cr_acc_x, mean_cr_acc_x, mean_cr_acc_z, mean_cr_acc_y, rms_cr_acc_z, mean_ch_acc_z, max_cr_acc_z, max_cr_acc_x, max_ch_acc_z, min_ch_acc_z, rms_ch_acc_z, mean_ch_acc_x, rms_ch_acc_x, max_cr_acc_y, min_cr_acc_x, max_th_acc_z, min_cr_acc_y, min_cr_acc_z, entr_cr_acc_z, frp_cr_acc_z, aad_cr_acc_x, rms_cr_gy_y, var_cr_acc_z, aad_cr_acc_z, mean_th_acc_z, min_ch_acc_x, cen_cr_acc_z, eng_cr_acc_z, min_cr_gy_z, slope_ch_gy_y, skew_cr_acc_z, rms_th_acc_z, var_cr_gy_y, aad_cr_gy_y, max_cr_gy_z, var_cr_acc_x, mean_cr_gy_z, frp_cr_acc_x, rms_th_acc_x, min_th_acc_z, slope_cr_acc_x, mean_ch_gy_y, mean_cr_gy_y, cen_ch_acc_z, mean_th_acc_x, aad_cr_gy_z, rms_cr_gy_z, kur_cr_acc_z, slope_ch_acc_z, max_cr_gy_y, aad_cr_acc_y, var_cr_gy_z, entr_cr_acc_x, slope_cr_acc_z, entr_ch_acc_z, var_cr_acc_y, cen_cr_acc_x, aad_ch_acc_z, min_cr_gy_y, slope_cr_acc_y, min_th_acc_y, rms_ch_gy_y, var_ch_acc_z, frp_cr_acc_y, max_ch_acc_x, max_th_acc_x, frp_th_acc_z, entr_cr_acc_y, mean_th_gy_y, var_th_gy_z, rms_cr_gy_x, min_th_gy_y, rms_th_gy_z, entr_th_acc_z, cen_cr_acc_y, aad_cr_gy_x, cen_th_acc_z, slope_ch_acc_x, var_cr_gy_x, aad_ch_acc_x, frp_ch_acc_z, max_th_gy_y, rms_ch_acc_y, min_th_acc_x, var_th_acc_y, max_th_gy_x, entr_cr_gy_y, rms_ch_gy_x, max_th_gy_z, max_th_acc_y, slope_th_acc_z, min_ch_gy_x, var_th_gy_x, min_th_gy_x, rms_ch_gy_z, mean_th_acc_y, var_ch_acc_x, var_ch_gy_x, var_ch_gy_y, max_ch_gy_y, eng_th_acc_y, min_ch_gy_y, aad_ch_gy_y, min_th_gy_z, var_th_gy_y, eng_th_acc_z, aad_th_gy_y, cen_cr_gy_y, var_ch_gy_z, eng_cr_acc_x, frp_cr_gy_y, min_cr_gy_x, frp_th_acc_y, kur_th_acc_z, rms_th_gy_y, eng_ch_acc_z, var_ch_acc_y, skew_th_acc_z, rms_th_gy_x, max_ch_acc_y, eng_cr_acc_y, kur_th_acc_y, aad_th_gy_z, var_th_acc_x, entr_cr_gy_z, cen_cr_gy_z, entr_th_acc_y, cen_ch_gy_y, frp_th_acc_x)
#Data Normilization

c=ncol(mydata)
features=mydata[,3:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata_t1_1=data.frame(window=c(1:max(adjwin)),label=wlabel,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata_t1_1), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]
```
###Test the Global Model with Optimal window size and classifier
```{r}
global_svm_pre<- predict(svmmodel, mydata_t1_1[,-1],type="class")
global_svmtime_classifying=system.time(global_svm_pre<- predict(svmmodel, mydata_t1_1[,-1],type="class"))
global_svmconf.matrix=confusionMatrix(global_svm_pre, mydata_t1_1$label)
global_svmacc=global_svmconf.matrix$overall[1]
```
###Feature Selection for Global Classifier
```{r}
# ensure the results are repeatable
set.seed(7)
# load the library
library("mlbench")
library("caret")
library("LiblineaR")
# define the control using a random forest selection function
control=rfeControl(functions=rfFuncs, method="cv", number=10)
# run the RFE algorithm
c=ncol(mydata3)

BF_TIME=system.time(results <- rfe(mydata3[,2:c], mydata3[,1], sizes=c(1:c), rfeControl=control))
# summarize the results
bestset=paste(as.character(results$optVariables), collapse=", ")
```








##Two Stage Classifier
##Stage 1-Finding interested activities from dataset
###Classifier 1 for walk and stand
###Train C1 and get result of interested activities (retain the lable for c2)
```{r}
#load data
setwd("D:/Academic/Human Posture Quatification/DataDriven/IMU-ML/Testing Data/Test 11_five sensor/c1")
Temp=read.csv(file = "SM1.csv",header = T)
Test=Temp[,-c(21)]
colnames(Test)[21] <- "label"
colnames(Test)[22] <- "label_c2"

##Data Segmentation Preparation
imudata=Test #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,23:25]=NA #create three empty columns
colnames(imudata)[23:25]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
library('clusterSim')
library("e1071")
library("caret")
library("rpart")
##Tesing different window size
#set up parameters with regard to the data collection condition
t=1.2#setting window size as t seconds (fixed)
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
wlabel_c2=aggregate(imudata$label_c2, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,label_c2=wlabel_c2,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)
#replace with bestset from feature selection
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_y, rms_cr_acc_x, mean_cr_acc_x, mean_cr_acc_z, mean_cr_acc_y, rms_cr_acc_z, mean_ch_acc_z, max_cr_acc_z, max_cr_acc_x, max_ch_acc_z, min_ch_acc_z, rms_ch_acc_z, mean_ch_acc_x, rms_ch_acc_x, max_cr_acc_y, min_cr_acc_x, max_th_acc_z, min_cr_acc_y, min_cr_acc_z, entr_cr_acc_z, frp_cr_acc_z, aad_cr_acc_x, rms_cr_gy_y, var_cr_acc_z, aad_cr_acc_z, mean_th_acc_z, min_ch_acc_x, cen_cr_acc_z, eng_cr_acc_z, min_cr_gy_z, slope_ch_gy_y, skew_cr_acc_z, rms_th_acc_z, var_cr_gy_y, aad_cr_gy_y, max_cr_gy_z, var_cr_acc_x, mean_cr_gy_z, frp_cr_acc_x, rms_th_acc_x, min_th_acc_z, slope_cr_acc_x, mean_ch_gy_y, mean_cr_gy_y, cen_ch_acc_z, mean_th_acc_x, aad_cr_gy_z, rms_cr_gy_z, kur_cr_acc_z, slope_ch_acc_z, max_cr_gy_y, aad_cr_acc_y, var_cr_gy_z, entr_cr_acc_x, slope_cr_acc_z, entr_ch_acc_z, var_cr_acc_y, cen_cr_acc_x, aad_ch_acc_z, min_cr_gy_y, slope_cr_acc_y, min_th_acc_y, rms_ch_gy_y, var_ch_acc_z, frp_cr_acc_y, max_ch_acc_x, max_th_acc_x, frp_th_acc_z, entr_cr_acc_y, mean_th_gy_y, var_th_gy_z, rms_cr_gy_x, min_th_gy_y, rms_th_gy_z, entr_th_acc_z, cen_cr_acc_y, aad_cr_gy_x, cen_th_acc_z, slope_ch_acc_x, var_cr_gy_x, aad_ch_acc_x, frp_ch_acc_z, max_th_gy_y, rms_ch_acc_y, min_th_acc_x, var_th_acc_y, max_th_gy_x, entr_cr_gy_y, rms_ch_gy_x, max_th_gy_z, max_th_acc_y, slope_th_acc_z, min_ch_gy_x, var_th_gy_x, min_th_gy_x, rms_ch_gy_z, mean_th_acc_y, var_ch_acc_x, var_ch_gy_x, var_ch_gy_y, max_ch_gy_y, eng_th_acc_y, min_ch_gy_y, aad_ch_gy_y, min_th_gy_z, var_th_gy_y, eng_th_acc_z, aad_th_gy_y, cen_cr_gy_y, var_ch_gy_z, eng_cr_acc_x, frp_cr_gy_y, min_cr_gy_x, frp_th_acc_y, kur_th_acc_z, rms_th_gy_y, eng_ch_acc_z, var_ch_acc_y, skew_th_acc_z, rms_th_gy_x, max_ch_acc_y, eng_cr_acc_y, kur_th_acc_y, aad_th_gy_z, var_th_acc_x, entr_cr_gy_z, cen_cr_gy_z, entr_th_acc_y, cen_ch_gy_y, frp_th_acc_x)
#Data Normilization

c=ncol(mydata)
features=mydata[,4:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,label_c2=wlabel_c2,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]

###KNN clustering
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata$label,p=0.8, list = FALSE)
mydata.training=mydata[index,]
mydata.testing=mydata[-index,]
#train the model
trctrl=trainControl(method="repeatedcv", number=10,repeats = 10)
set.seed(9)
grid=expand.grid(k=c(1:20))
set.seed(9)
c=ncol(mydata)
c1_model.knn=train(mydata.training[, 4:c], mydata.training[, 2], method='knn',trControl=trctrl,tuneGrid = grid,tuneLength = 1)
c1_knntime_training=system.time(train(mydata.training[, 4:c], mydata.training[, 2], method='knn',trControl=trctrl,tuneGrid = grid,tuneLength = 1))
set.seed(9)
c1_predictions=predict(object = c1_model.knn,mydata.testing[,4:c])
c1_knnconf.matrix=confusionMatrix(c1_predictions,mydata.testing[,2])
c1_knntime=system.time(p<- predict(object = c1_model.knn,mydata.testing[,4:c]))
c1_knnacc=c1_knnconf.matrix$overall[1]
```

##Stage 2-Finding the detailed activities from interested dataset
###Train C2 classifier
```{r}
#load data
setwd("D:/Academic/Human Posture Quatification/DataDriven/IMU-ML/Testing Data/Test 11_five sensor/c1")
Temp=read.csv(file = "SM1.csv",header = T)
Test=Temp[,-c(21,22)]
colnames(Test)[21] <- "label_c2"
##Data Segmentation Preparation
imudata=Test #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,22:24]=NA #create three empty columns
colnames(imudata)[22:24]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
library('clusterSim')
library("e1071")
library("caret")
library("rpart")
##Tesing different window size
#set up parameters with regard to the data collection condition
t=1.2#setting window size as t seconds (fixed)
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
#wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
wlabel_c2=aggregate(imudata$label_c2, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
mydata=data.frame(window=c(1:max(adjwin)),label_c2=wlabel_c2,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)
#replace with bestset from feature selection
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_x, mean_cr_gy_y, mean_cr_acc_z, mean_cr_acc_x, rms_cr_acc_z, entr_cr_acc_z, min_cr_acc_x, min_cr_acc_z, frp_cr_acc_z, mean_cr_acc_y, cen_ch_acc_y, mean_ch_acc_x, mean_ch_acc_z, rms_ch_acc_x, cen_cr_acc_z, min_ch_acc_x, slope_cr_acc_z, rms_th_acc_x, mean_th_acc_z, rms_cr_gy_y, slope_cr_acc_x, mean_th_acc_x, rms_ch_acc_z, frp_cr_acc_y, mean_th_acc_y, rms_th_acc_z, mean_ch_acc_y, max_cr_acc_z, mean_cr_gy_z, var_cr_acc_z, aad_cr_acc_x, entr_cr_acc_y, entr_ch_acc_y, rms_cr_acc_y, mean_th_gy_z, rms_cr_gy_z, max_cr_acc_x, max_th_acc_x, aad_cr_acc_z, cen_cr_acc_y, eng_cr_acc_y, min_ch_acc_z, var_cr_acc_x, max_cr_gy_y, rms_ch_acc_y, min_th_acc_z, mean_th_gy_y, slope_th_acc_y, mean_ch_gy_y, rms_th_acc_y, aad_cr_gy_z, min_cr_acc_y, var_cr_gy_z, aad_cr_acc_y, slope_ch_acc_y, mean_ch_gy_x, frp_cr_acc_x, max_th_gy_z, slope_cr_acc_y, entr_cr_acc_x, aad_cr_gy_y, slope_ch_acc_x, max_th_acc_z, max_th_gy_y, var_cr_acc_y, entr_th_acc_z, mean_ch_gy_z, slope_th_acc_x, slope_th_acc_z, cen_th_acc_z, eng_cr_acc_z, slope_ch_gy_y, max_ch_acc_z, slope_ch_acc_z, cen_cr_acc_x, min_cr_gy_y, frp_ch_acc_y, aad_th_gy_x, min_ch_acc_y, max_ch_gy_x, aad_ch_acc_y, frp_cr_gy_z, skew_cr_acc_y, skew_ch_acc_y, max_th_acc_y, max_ch_acc_x, rms_cr_gy_x, max_cr_gy_x, min_ch_gy_y, slope_ch_gy_z, kur_ch_acc_y, frp_th_acc_z, rms_th_gy_z, eng_ch_acc_y, max_cr_gy_z, max_ch_acc_y, max_ch_gy_z, max_cr_acc_y, eng_cr_gy_z, aad_th_gy_z, frp_cr_gy_y, min_ch_gy_x, min_th_acc_x, cen_cr_gy_z, rms_th_gy_x, var_ch_acc_y, var_cr_gy_y, max_ch_gy_y, min_th_gy_y, aad_ch_gy_x, cen_cr_gy_x, min_th_gy_z, min_cr_gy_z, eng_th_gy_y, entr_cr_gy_z, cen_cr_gy_y, kur_cr_gy_z, rms_ch_gy_x, var_ch_gy_x, var_cr_gy_x, entr_th_gy_y, aad_cr_gy_x, slope_th_gy_z, skew_cr_gy_z, aad_ch_gy_y, kur_cr_acc_y, skew_ch_acc_z, kur_cr_acc_x, var_ch_acc_x, frp_ch_gy_y, var_th_gy_x, rms_th_gy_y, eng_ch_acc_z, var_th_acc_y, slope_th_gy_y, var_th_gy_z, skew_cr_gy_y, var_ch_gy_y, kur_cr_acc_z, cen_th_acc_x, aad_ch_acc_z)
#Data Normilization

c=ncol(mydata)
features=mydata[,3:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata=data.frame(window=c(1:max(adjwin)),label_c2=wlabel_c2,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]

#Machine Learning
## Data preparation

library("e1071")
c=ncol(mydata)
mydata3=mydata[,2:c] #deleted the window index
#constructing the training and testing set by 80% to 20%
set.seed(9)
index=createDataPartition(mydata3$label_c2,p=0.8, list = FALSE)
mydata3.training=mydata3[index,]
mydata3.testing=mydata3[-index,]
c2_nbmodel=naiveBayes(label_c2~., data=mydata3.training)
#Test performance of the trained model with Confusion Matrix
set.seed(123)
p<- predict(c2_nbmodel, mydata3.testing,type="class")
c2_conf.matrix=confusionMatrix(p, mydata3.testing$label)
```

#Test on Test11_T1_1
##Data segmentation-with specified window size
```{r}
setwd("D:/Academic/Human Posture Quatification/DataDriven/IMU-ML/Testing Data/Test 11_five sensor/t1/t1-1")
#load labelled data
Test=read.csv(file = "Test11-t1_1_label.csv",header = T)
```


```{r}
##Data Segmentation
imudata=Test #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,22:24]=NA #create three empty columns
colnames(imudata)[22:24]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#set up parameters with regard to the data collection condition
t=1.2 #setting window size as t seconds (fixed)
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
```

##Feature Construction
```{r}
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)
#replace with bestset from feature selection
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_x, mean_cr_gy_y, mean_cr_acc_z, mean_cr_acc_x, rms_cr_acc_z, entr_cr_acc_z, min_cr_acc_x, min_cr_acc_z, frp_cr_acc_z, mean_cr_acc_y, cen_ch_acc_y, mean_ch_acc_x, mean_ch_acc_z, rms_ch_acc_x, cen_cr_acc_z, min_ch_acc_x, slope_cr_acc_z, rms_th_acc_x, mean_th_acc_z, rms_cr_gy_y, slope_cr_acc_x, mean_th_acc_x, rms_ch_acc_z, frp_cr_acc_y, mean_th_acc_y, rms_th_acc_z, mean_ch_acc_y, max_cr_acc_z, mean_cr_gy_z, var_cr_acc_z, aad_cr_acc_x, entr_cr_acc_y, entr_ch_acc_y, rms_cr_acc_y, mean_th_gy_z, rms_cr_gy_z, max_cr_acc_x, max_th_acc_x, aad_cr_acc_z, cen_cr_acc_y, eng_cr_acc_y, min_ch_acc_z, var_cr_acc_x, max_cr_gy_y, rms_ch_acc_y, min_th_acc_z, mean_th_gy_y, slope_th_acc_y, mean_ch_gy_y, rms_th_acc_y, aad_cr_gy_z, min_cr_acc_y, var_cr_gy_z, aad_cr_acc_y, slope_ch_acc_y, mean_ch_gy_x, frp_cr_acc_x, max_th_gy_z, slope_cr_acc_y, entr_cr_acc_x, aad_cr_gy_y, slope_ch_acc_x, max_th_acc_z, max_th_gy_y, var_cr_acc_y, entr_th_acc_z, mean_ch_gy_z, slope_th_acc_x, slope_th_acc_z, cen_th_acc_z, eng_cr_acc_z, slope_ch_gy_y, max_ch_acc_z, slope_ch_acc_z, cen_cr_acc_x, min_cr_gy_y, frp_ch_acc_y, aad_th_gy_x, min_ch_acc_y, max_ch_gy_x, aad_ch_acc_y, frp_cr_gy_z, skew_cr_acc_y, skew_ch_acc_y, max_th_acc_y, max_ch_acc_x, rms_cr_gy_x, max_cr_gy_x, min_ch_gy_y, slope_ch_gy_z, kur_ch_acc_y, frp_th_acc_z, rms_th_gy_z, eng_ch_acc_y, max_cr_gy_z, max_ch_acc_y, max_ch_gy_z, max_cr_acc_y, eng_cr_gy_z, aad_th_gy_z, frp_cr_gy_y, min_ch_gy_x, min_th_acc_x, cen_cr_gy_z, rms_th_gy_x, var_ch_acc_y, var_cr_gy_y, max_ch_gy_y, min_th_gy_y, aad_ch_gy_x, cen_cr_gy_x, min_th_gy_z, min_cr_gy_z, eng_th_gy_y, entr_cr_gy_z, cen_cr_gy_y, kur_cr_gy_z, rms_ch_gy_x, var_ch_gy_x, var_cr_gy_x, entr_th_gy_y, aad_cr_gy_x, slope_th_gy_z, skew_cr_gy_z, aad_ch_gy_y, kur_cr_acc_y, skew_ch_acc_z, kur_cr_acc_x, var_ch_acc_x, frp_ch_gy_y, var_th_gy_x, rms_th_gy_y, eng_ch_acc_z, var_th_acc_y, slope_th_gy_y, var_th_gy_z, skew_cr_gy_y, var_ch_gy_y, kur_cr_acc_z, cen_th_acc_x, aad_ch_acc_z)
#Data Normilization

c=ncol(mydata)
features=mydata[,3:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata_t1_1=data.frame(window=c(1:max(adjwin)),label=wlabel,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata_t1_1), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]
```
##Classify the activities
###Gblobal Approach
```{r}
global_svm_pre<- predict(svmmodel, mydata_t1_1[,-1],type="class")
global_svmtime_classifying=system.time(global_svm_pre<- predict(svmmodel, mydata_t1_1[,-1],type="class"))
global_svmconf.matrix=confusionMatrix(global_svm_pre, mydata_t1_1$label)
global_svmacc=global_svmconf.matrix$overall[1]
```
###Two Stage Approach
####Get two stage labelelled data
```{r}
#load data
setwd("D:/Academic/Human Posture Quatification/DataDriven/IMU-ML/Testing Data/Test 11_five sensor/t1/t1-1")
Temp=read.csv(file = "Test11-t1_1_label_twostage.csv",header = T)
Test=Temp[,-c(21)]
colnames(Test)[21] <- "label"
colnames(Test)[22] <- "label_c2"

##Data Segmentation Preparation
imudata=Test #import labelled data
#set the "window" size "n" seconds by setting segmentation lables, add a lable colum onto the current dataframe
imudata[,23:25]=NA #create three empty columns
colnames(imudata)[23:25]=c("window","gindex","adjwin")
#define the variables
ela=imudata$elapsed
window=imudata$window
index=imudata$index
gindex=imudata$gindex
adjwin=imudata$adjwin
#package installation
library("seewave")
library("base")
library("trend")
library("moments")
library("BBmisc")
library('clusterSim')
library("e1071")
library("caret")
library("rpart")
##Tesing different window size
#set up parameters with regard to the data collection condition
t=1.2#setting window size as t seconds (fixed)
n=(floor(imudata$elapsed[nrow(imudata)]))/t #determine the number of total windows "n"
f=50#determine the maximum frequency of the sensor data "f"
j=1#initialize the window count as 1 (because we delete the first second, the ela starts from 1.000s)
for (i in 1:nrow(imudata))
  {
  if(ela[i]<1+j*t)
  {
  window[i]=j
  }
  else
  j=j+1
  window[i]=j
}
imudata$window=window
#assigining index to data in the same window
k=1 #setting the initial index in window
l=1 #setting the initial gindex as 1
#assiging the within window index
  for (j in 1:nrow(imudata))
  {
    
          if (window[j]==k)
    {
      gindex[j]=l
      l=l+1
    }
    else
    {
      k=k+1
      l=1
      gindex[j]=l
      l=l+1
    }
  }
imudata$gindex=gindex

#making the p percent overlapping window
winsize=table(window)#store the window size
p=0.5 #50% overlapping window
for (i in 1:nrow(imudata))
{
    if(gindex[i]<floor(winsize[window[i]]-winsize[window[i]]*p))
    {
      adjwin[i]=window[i]
    }
    else
      adjwin[i]=window[i]+1
}
imudata$adjwin=adjwin
##Labelling each window through voting
#create a vector for storing window label
wlabel=aggregate(imudata$label, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
wlabel_c2=aggregate(imudata$label_c2, list(imudata$adjwin), function(x) c(maj = names(which.max(table(x)))))$x
#Feature Construction
##Time related features
#adjust to the adjwin
n=max(adjwin)
### X-axis
#sensor-th
#Minimum
min_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_x
min_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_x
#Maximum
max_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_x
max_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_x
#Mean Value
mean_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_x
mean_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_x
#Variance
var_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_x
var_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_x
#Average absolute deviation
aad_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_x
aad_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_x
#RMS
rms_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_x
rms_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_x
#Zero-crossing rate
zcr_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_x
zcr_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_x
#Sign
sign_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_x
sign_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_x
#Slope (Sen's Slope)
slope_th_acc_x=aggregate(th_acc_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_x
slope_th_gy_x=aggregate(th_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_x



#sensor-cr
#Minimum
min_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_x
min_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_x
#Maximum
max_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_x
max_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_x
#Mean Value
mean_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_x
mean_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_x
#Variance
var_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_x
var_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_x
#Average absolute deviation
aad_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_x
aad_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_x
#RMS
rms_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_x
rms_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_x
#Zero-crossing rate
zcr_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_x
zcr_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_x
#Sign
sign_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_x
sign_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_x
#Slope (Sen's Slope)
slope_cr_acc_x=aggregate(cr_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_x
slope_cr_gy_x=aggregate(cr_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_x


#sensor-ch
#Minimum
min_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_x
min_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_x
#Maximum
max_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_x
max_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_x
#Mean Value
mean_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_x
mean_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_x
#Variance
var_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_x
var_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_x
#Average absolute deviation
aad_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_x
aad_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_x
#RMS
rms_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_x
rms_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_x
#Zero-chossing rate
zcr_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_x
zcr_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_x
#Sign
sign_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_x
sign_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_x
#Slope (Sen's Slope)
slope_ch_acc_x=aggregate(ch_ac_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_x
slope_ch_gy_x=aggregate(ch_gy_x~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_x


### Y-axis
#sensor-th
#Minimum
min_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_y
min_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_y
#Maximum
max_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_y
max_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_y
#Mean Value
mean_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_y
mean_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_y
#Variance
var_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_y
var_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_y
#Average absolute deviation
aad_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_y
aad_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_y
#RMS
rms_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_y
rms_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_y
#Zero-crossing rate
zcr_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_y
zcr_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_y
#Sign
sign_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_y
sign_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_y
#Slope (Sen's Slope)
slope_th_acc_y=aggregate(th_acc_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_y
slope_th_gy_y=aggregate(th_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_y

#sensor-cr
#Minimum
min_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_y
min_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_y
#Maximum
max_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_y
max_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_y
#Mean Value
mean_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_y
mean_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_y
#Variance
var_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_y
var_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_y
#Average absolute deviation
aad_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_y
aad_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_y
#RMS
rms_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_y
rms_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_y
#Zero-crossing rate
zcr_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_y
zcr_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_y
#Sign
sign_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_y
sign_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_y
#Slope (Sen's Slope)
slope_cr_acc_y=aggregate(cr_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_y
slope_cr_gy_y=aggregate(cr_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_y

#sensor-ch
#Minimum
min_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_y
min_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_y
#Maximum
max_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_y
max_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_y
#Mean Value
mean_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_y
mean_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_y
#Variance
var_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_y
var_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_y
#Average absolute deviation
aad_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_y
aad_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_y
#RMS
rms_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_y
rms_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_y
#Zero-chossing rate
zcr_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_y
zcr_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_y
#Sign
sign_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_y
sign_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_y
#Slope (Sen's Slope)
slope_ch_acc_y=aggregate(ch_ac_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_y
slope_ch_gy_y=aggregate(ch_gy_y~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_y

### Z-axis
#sensor-th
#Minimum
min_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(min = min(x)))$th_acc_z
min_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$th_gy_z
#Maximum
max_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(max = max(x)))$th_acc_z
max_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$th_gy_z
#Mean Value
mean_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_acc_z
mean_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$th_gy_z
#Variance
var_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_acc_z
var_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$th_gy_z
#Average absolute deviation
aad_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_acc_z
aad_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$th_gy_z
#RMS
rms_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_acc_z
rms_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$th_gy_z
#Zero-crossing rate
zcr_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_acc_z
zcr_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$th_gy_z
#Sign
sign_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_acc_z
sign_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$th_gy_z
#Slope (Sen's Slope)
slope_th_acc_z=aggregate(th_acc_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_acc_z
slope_th_gy_z=aggregate(th_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$th_gy_z


#sensor-cr
#Minimum
min_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_ac_z
min_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$cr_gy_z
#Maximum
max_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_ac_z
max_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$cr_gy_z
#Mean Value
mean_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_ac_z
mean_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$cr_gy_z
#Variance
var_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_ac_z
var_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$cr_gy_z
#Average absolute deviation
aad_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_ac_z
aad_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$cr_gy_z
#RMS
rms_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_ac_z
rms_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$cr_gy_z
#Zero-crossing rate
zcr_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_ac_z
zcr_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$cr_gy_z
#Sign
sign_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_ac_z
sign_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$cr_gy_z
#Slope (Sen's Slope)
slope_cr_acc_z=aggregate(cr_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_ac_z
slope_cr_gy_z=aggregate(cr_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$cr_gy_z


#sensor-ch
#Minimum
min_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_ac_z
min_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(min = min(x)))$ch_gy_z
#Maximum
max_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_ac_z
max_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(max = max(x)))$ch_gy_z
#Mean Value
mean_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_ac_z
mean_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(mean = mean(x)))$ch_gy_z
#Variance
var_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_ac_z
var_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(sd = sd(x)))$ch_gy_z
#Average absolute deviation
aad_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_ac_z
aad_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(abd = mad(x,center = mean(x))))$ch_gy_z
#RMS
rms_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_ac_z
rms_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(rms = rms(x)))$ch_gy_z
#Zero-chossing rate
zcr_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_ac_z
zcr_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(zcr = zcr(x,f,plot=F,wl=NULL)))$ch_gy_z
#Sign
sign_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_ac_z
sign_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(signs = sign(mean(x))))$ch_gy_z
#Slope (Sen's Slope)
slope_ch_acc_z=aggregate(ch_ac_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_ac_z
slope_ch_gy_z=aggregate(ch_gy_z~ adjwin, imudata, function(x) c(slope = sens.slope(x)$estimates))$ch_gy_z


##Frequency related features
###X-axis

##sensor-th
##Entropy
entr_th_acc_x=c(1:n) 
entr_th_gy_x=c(1:n)
##Energy
eng_th_acc_x=c(1:n)
eng_th_gy_x=c(1:n)
##Spectral Centroid
cen_th_acc_x=c(1:n)
cen_th_gy_x=c(1:n)
##Frequency Range Power
frp_th_acc_x=c(1:n)
frp_th_gy_x=c(1:n)
##Skewness of frequency
skew_th_acc_x=c(1:n)
skew_th_gy_x=c(1:n)
##kurtosis of frequency
kur_th_acc_x=c(1:n)
kur_th_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_x=spec(subst$th_acc_x,f=f,plot=F)
  spec_th_gy_x=spec(subst$th_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_x[i]=sh(spec_th_acc_x,alpha = "shannon")
  entr_th_gy_x[i]=sh(spec_th_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_x[i]=sum(spec_th_acc_x[,2]^2)
  eng_th_gy_x[i]=sum(spec_th_gy_x[,2]^2)
  #Spectral Centroid
  cen_th_acc_x[i]=specprop(spec_th_acc_x,f=f,plot=F)$cent
  cen_th_gy_x[i]=specprop(spec_th_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_x[i]=sum(abs(spec_th_acc_x[,2]))
  frp_th_gy_x[i]=sum(abs(spec_th_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_x[i]=skewness(spec_th_acc_x[,2])
  skew_th_gy_x[i]=skewness(spec_th_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_x[i]=kurtosis(spec_th_acc_x[,2])
  kur_th_gy_x[i]=kurtosis(spec_th_gy_x[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_x=c(1:n) 
entr_cr_gy_x=c(1:n)
##Energy
eng_cr_acc_x=c(1:n)
eng_cr_gy_x=c(1:n)
##Spectral Centroid
cen_cr_acc_x=c(1:n)
cen_cr_gy_x=c(1:n)
##Frequency Range Power
frp_cr_acc_x=c(1:n)
frp_cr_gy_x=c(1:n)
##Skewness of frequency
skew_cr_acc_x=c(1:n)
skew_cr_gy_x=c(1:n)
##kurtosis of frequency
kur_cr_acc_x=c(1:n)
kur_cr_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_x=spec(subst$cr_ac_x,f=f,plot=F)
  spec_cr_gy_x=spec(subst$cr_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_x[i]=sh(spec_cr_acc_x,alpha = "shannon")
  entr_cr_gy_x[i]=sh(spec_cr_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_x[i]=sum(spec_cr_acc_x[,2]^2)
  eng_cr_gy_x[i]=sum(spec_cr_gy_x[,2]^2)
  #Spectral Centroid
  cen_cr_acc_x[i]=specprop(spec_cr_acc_x,f=f,plot=F)$cent
  cen_cr_gy_x[i]=specprop(spec_cr_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_x[i]=sum(abs(spec_cr_acc_x[,2]))
  frp_cr_gy_x[i]=sum(abs(spec_cr_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_x[i]=skewness(spec_cr_acc_x[,2])
  skew_cr_gy_x[i]=skewness(spec_cr_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_x[i]=kurtosis(spec_cr_acc_x[,2])
  kur_cr_gy_x[i]=kurtosis(spec_cr_gy_x[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_x=c(1:n) 
entr_ch_gy_x=c(1:n)
##Energy
eng_ch_acc_x=c(1:n)
eng_ch_gy_x=c(1:n)
##Spectral Centroid
cen_ch_acc_x=c(1:n)
cen_ch_gy_x=c(1:n)
##Frequency Range Power
frp_ch_acc_x=c(1:n)
frp_ch_gy_x=c(1:n)
##Skewness of frequency
skew_ch_acc_x=c(1:n)
skew_ch_gy_x=c(1:n)
##kurtosis of frequency
kur_ch_acc_x=c(1:n)
kur_ch_gy_x=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_x=spec(subst$ch_ac_x,f=f,plot=F)
  spec_ch_gy_x=spec(subst$ch_gy_x,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_x[i]=sh(spec_ch_acc_x,alpha = "shannon")
  entr_ch_gy_x[i]=sh(spec_ch_gy_x,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_x[i]=sum(spec_ch_acc_x[,2]^2)
  eng_ch_gy_x[i]=sum(spec_ch_gy_x[,2]^2)
  #Spectral Centroid
  cen_ch_acc_x[i]=specprop(spec_ch_acc_x,f=f,plot=F)$cent
  cen_ch_gy_x[i]=specprop(spec_ch_gy_x,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_x[i]=sum(abs(spec_ch_acc_x[,2]))
  frp_ch_gy_x[i]=sum(abs(spec_ch_gy_x[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_x[i]=skewness(spec_ch_acc_x[,2])
  skew_ch_gy_x[i]=skewness(spec_ch_gy_x[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_x[i]=kurtosis(spec_ch_acc_x[,2])
  kur_ch_gy_x[i]=kurtosis(spec_ch_gy_x[,2])
}

###Y-axis

##sensor-th
##Entropy
entr_th_acc_y=c(1:n) 
entr_th_gy_y=c(1:n)
##Energy
eng_th_acc_y=c(1:n)
eng_th_gy_y=c(1:n)
##Spectral Centroid
cen_th_acc_y=c(1:n)
cen_th_gy_y=c(1:n)
##Frequency Range Power
frp_th_acc_y=c(1:n)
frp_th_gy_y=c(1:n)
##Skewness of frequency
skew_th_acc_y=c(1:n)
skew_th_gy_y=c(1:n)
##kurtosis of frequency
kur_th_acc_y=c(1:n)
kur_th_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_y=spec(subst$th_acc_y,f=f,plot=F)
  spec_th_gy_y=spec(subst$th_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_y[i]=sh(spec_th_acc_y,alpha = "shannon")
  entr_th_gy_y[i]=sh(spec_th_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_y[i]=sum(spec_th_acc_y[,2]^2)
  eng_th_gy_y[i]=sum(spec_th_gy_y[,2]^2)
  #Spectral Centroid
  cen_th_acc_y[i]=specprop(spec_th_acc_y,f=f,plot=F)$cent
  cen_th_gy_y[i]=specprop(spec_th_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_y[i]=sum(abs(spec_th_acc_y[,2]))
  frp_th_gy_y[i]=sum(abs(spec_th_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_y[i]=skewness(spec_th_acc_y[,2])
  skew_th_gy_y[i]=skewness(spec_th_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_y[i]=kurtosis(spec_th_acc_y[,2])
  kur_th_gy_y[i]=kurtosis(spec_th_gy_y[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_y=c(1:n) 
entr_cr_gy_y=c(1:n)
##Energy
eng_cr_acc_y=c(1:n)
eng_cr_gy_y=c(1:n)
##Spectral Centroid
cen_cr_acc_y=c(1:n)
cen_cr_gy_y=c(1:n)
##Frequency Range Power
frp_cr_acc_y=c(1:n)
frp_cr_gy_y=c(1:n)
##Skewness of frequency
skew_cr_acc_y=c(1:n)
skew_cr_gy_y=c(1:n)
##kurtosis of frequency
kur_cr_acc_y=c(1:n)
kur_cr_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_y=spec(subst$cr_ac_y,f=f,plot=F)
  spec_cr_gy_y=spec(subst$cr_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_y[i]=sh(spec_cr_acc_y,alpha = "shannon")
  entr_cr_gy_y[i]=sh(spec_cr_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_y[i]=sum(spec_cr_acc_y[,2]^2)
  eng_cr_gy_y[i]=sum(spec_cr_gy_y[,2]^2)
  #Spectral Centroid
  cen_cr_acc_y[i]=specprop(spec_cr_acc_y,f=f,plot=F)$cent
  cen_cr_gy_y[i]=specprop(spec_cr_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_y[i]=sum(abs(spec_cr_acc_y[,2]))
  frp_cr_gy_y[i]=sum(abs(spec_cr_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_y[i]=skewness(spec_cr_acc_y[,2])
  skew_cr_gy_y[i]=skewness(spec_cr_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_y[i]=kurtosis(spec_cr_acc_y[,2])
  kur_cr_gy_y[i]=kurtosis(spec_cr_gy_y[,2])
}


##sensor-ch
##Entropy
entr_ch_acc_y=c(1:n) 
entr_ch_gy_y=c(1:n)
##Energy
eng_ch_acc_y=c(1:n)
eng_ch_gy_y=c(1:n)
##Spectral Centroid
cen_ch_acc_y=c(1:n)
cen_ch_gy_y=c(1:n)
##Frequency Range Power
frp_ch_acc_y=c(1:n)
frp_ch_gy_y=c(1:n)
##Skewness of frequency
skew_ch_acc_y=c(1:n)
skew_ch_gy_y=c(1:n)
##kurtosis of frequency
kur_ch_acc_y=c(1:n)
kur_ch_gy_y=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_y=spec(subst$ch_ac_y,f=f,plot=F)
  spec_ch_gy_y=spec(subst$ch_gy_y,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_y[i]=sh(spec_ch_acc_y,alpha = "shannon")
  entr_ch_gy_y[i]=sh(spec_ch_gy_y,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_y[i]=sum(spec_ch_acc_y[,2]^2)
  eng_ch_gy_y[i]=sum(spec_ch_gy_y[,2]^2)
  #Spectral Centroid
  cen_ch_acc_y[i]=specprop(spec_ch_acc_y,f=f,plot=F)$cent
  cen_ch_gy_y[i]=specprop(spec_ch_gy_y,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_y[i]=sum(abs(spec_ch_acc_y[,2]))
  frp_ch_gy_y[i]=sum(abs(spec_ch_gy_y[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_y[i]=skewness(spec_ch_acc_y[,2])
  skew_ch_gy_y[i]=skewness(spec_ch_gy_y[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_y[i]=kurtosis(spec_ch_acc_y[,2])
  kur_ch_gy_y[i]=kurtosis(spec_ch_gy_y[,2])
}

###Z-axis

##sensor-th
##Entropy
entr_th_acc_z=c(1:n) 
entr_th_gy_z=c(1:n)
##Energy
eng_th_acc_z=c(1:n)
eng_th_gy_z=c(1:n)
##Spectral Centroid
cen_th_acc_z=c(1:n)
cen_th_gy_z=c(1:n)
##Frequency Range Power
frp_th_acc_z=c(1:n)
frp_th_gy_z=c(1:n)
##Skewness of frequency
skew_th_acc_z=c(1:n)
skew_th_gy_z=c(1:n)
##kurtosis of frequency
kur_th_acc_z=c(1:n)
kur_th_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_th_acc_z=spec(subst$th_acc_z,f=f,plot=F)
  spec_th_gy_z=spec(subst$th_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_th_acc_z[i]=sh(spec_th_acc_z,alpha = "shannon")
  entr_th_gy_z[i]=sh(spec_th_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_th_acc_z[i]=sum(spec_th_acc_z[,2]^2)
  eng_th_gy_z[i]=sum(spec_th_gy_z[,2]^2)
  #Spectral Centroid
  cen_th_acc_z[i]=specprop(spec_th_acc_z,f=f,plot=F)$cent
  cen_th_gy_z[i]=specprop(spec_th_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_th_acc_z[i]=sum(abs(spec_th_acc_z[,2]))
  frp_th_gy_z[i]=sum(abs(spec_th_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_th_acc_z[i]=skewness(spec_th_acc_z[,2])
  skew_th_gy_z[i]=skewness(spec_th_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_th_acc_z[i]=kurtosis(spec_th_acc_z[,2])
  kur_th_gy_z[i]=kurtosis(spec_th_gy_z[,2])
}

##sensor-cr
##Entropy
entr_cr_acc_z=c(1:n) 
entr_cr_gy_z=c(1:n)
##Energy
eng_cr_acc_z=c(1:n)
eng_cr_gy_z=c(1:n)
##Spectral Centroid
cen_cr_acc_z=c(1:n)
cen_cr_gy_z=c(1:n)
##Frequency Range Power
frp_cr_acc_z=c(1:n)
frp_cr_gy_z=c(1:n)
##Skewness of frequency
skew_cr_acc_z=c(1:n)
skew_cr_gy_z=c(1:n)
##kurtosis of frequency
kur_cr_acc_z=c(1:n)
kur_cr_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_cr_acc_z=spec(subst$cr_ac_z,f=f,plot=F)
  spec_cr_gy_z=spec(subst$cr_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_cr_acc_z[i]=sh(spec_cr_acc_z,alpha = "shannon")
  entr_cr_gy_z[i]=sh(spec_cr_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_cr_acc_z[i]=sum(spec_cr_acc_z[,2]^2)
  eng_cr_gy_z[i]=sum(spec_cr_gy_z[,2]^2)
  #Spectral Centroid
  cen_cr_acc_z[i]=specprop(spec_cr_acc_z,f=f,plot=F)$cent
  cen_cr_gy_z[i]=specprop(spec_cr_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_cr_acc_z[i]=sum(abs(spec_cr_acc_z[,2]))
  frp_cr_gy_z[i]=sum(abs(spec_cr_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_cr_acc_z[i]=skewness(spec_cr_acc_z[,2])
  skew_cr_gy_z[i]=skewness(spec_cr_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_cr_acc_z[i]=kurtosis(spec_cr_acc_z[,2])
  kur_cr_gy_z[i]=kurtosis(spec_cr_gy_z[,2])
}

##sensor-ch
##Entropy
entr_ch_acc_z=c(1:n) 
entr_ch_gy_z=c(1:n)
##Energy
eng_ch_acc_z=c(1:n)
eng_ch_gy_z=c(1:n)
##Spectral Centroid
cen_ch_acc_z=c(1:n)
cen_ch_gy_z=c(1:n)
##Frequency Range Power
frp_ch_acc_z=c(1:n)
frp_ch_gy_z=c(1:n)
##Skewness of frequency
skew_ch_acc_z=c(1:n)
skew_ch_gy_z=c(1:n)
##kurtosis of frequency
kur_ch_acc_z=c(1:n)
kur_ch_gy_z=c(1:n)
for (i in 1:n)
{
  #calculate the frequency spectrum in each adjwin
  subst=subset.data.frame(imudata,imudata$adjwin==i)
  spec_ch_acc_z=spec(subst$ch_ac_z,f=f,plot=F)
  spec_ch_gy_z=spec(subst$ch_gy_z,f=f,plot=F)
  #calculate the frequency entropy in each adjwin
  entr_ch_acc_z[i]=sh(spec_ch_acc_z,alpha = "shannon")
  entr_ch_gy_z[i]=sh(spec_ch_gy_z,alpha = "shannon")#for the shannon entropy see documentation
  #Signal energy in each adjwin
  eng_ch_acc_z[i]=sum(spec_ch_acc_z[,2]^2)
  eng_ch_gy_z[i]=sum(spec_ch_gy_z[,2]^2)
  #Spectral Centroid
  cen_ch_acc_z[i]=specprop(spec_ch_acc_z,f=f,plot=F)$cent
  cen_ch_gy_z[i]=specprop(spec_ch_gy_z,f=f,plot=F)$cent
  #Frequency Range Power: this is similar to the signal frequency power, but just using the absolute value
  frp_ch_acc_z[i]=sum(abs(spec_ch_acc_z[,2]))
  frp_ch_gy_z[i]=sum(abs(spec_ch_gy_z[,2]))
  #Skewness of frequency: Measuring the symetric of frequency distribution
  skew_ch_acc_z[i]=skewness(spec_ch_acc_z[,2])
  skew_ch_gy_z[i]=skewness(spec_ch_gy_z[,2])
  #kurtosis of frequency: Measuring the heavy tail of frequency distribution
  kur_ch_acc_z[i]=kurtosis(spec_ch_acc_z[,2])
  kur_ch_gy_z[i]=kurtosis(spec_ch_gy_z[,2])
}

#Build the read-to-use dataset (full feature original)
#mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,label_c2=wlabel_c2,min_th_acc_x,min_th_gy_x,max_th_acc_x,max_th_gy_x,mean_th_acc_x,mean_th_gy_x,var_th_acc_x,var_th_gy_x,aad_th_acc_x,aad_th_gy_x,rms_th_acc_x,rms_th_gy_x,slope_th_acc_x,slope_th_gy_x,entr_th_acc_x,entr_th_gy_x,eng_th_acc_x,eng_th_gy_x,cen_th_acc_x,cen_th_gy_x,frp_th_acc_x,frp_th_gy_x,skew_th_acc_x,skew_th_gy_x,kur_th_acc_x,kur_th_gy_x,min_cr_acc_x,min_cr_gy_x,max_cr_acc_x,max_cr_gy_x,mean_cr_acc_x,mean_cr_gy_x,var_cr_acc_x,var_cr_gy_x,aad_cr_acc_x,aad_cr_gy_x,rms_cr_acc_x,rms_cr_gy_x,slope_cr_acc_x,slope_cr_gy_x,entr_cr_acc_x,entr_cr_gy_x,eng_cr_acc_x,eng_cr_gy_x,cen_cr_acc_x,cen_cr_gy_x,frp_cr_acc_x,frp_cr_gy_x,skew_cr_acc_x,skew_cr_gy_x,kur_cr_acc_x,kur_cr_gy_x,min_th_acc_y,min_th_gy_y,max_th_acc_y,max_th_gy_y,mean_th_acc_y,mean_th_gy_y,var_th_acc_y,var_th_gy_y,aad_th_acc_y,aad_th_gy_y,rms_th_acc_y,rms_th_gy_y,slope_th_acc_y,slope_th_gy_y,entr_th_acc_y,entr_th_gy_y,eng_th_acc_y,eng_th_gy_y,cen_th_acc_y,cen_th_gy_y,frp_th_acc_y,frp_th_gy_y,skew_th_acc_y,skew_th_gy_y,kur_th_acc_y,kur_th_gy_y,min_cr_acc_y,min_cr_gy_y,max_cr_acc_y,max_cr_gy_y,mean_cr_acc_y,mean_cr_gy_y,var_cr_acc_y,var_cr_gy_y,aad_cr_acc_y,aad_cr_gy_y,rms_cr_acc_y,rms_cr_gy_y,slope_cr_acc_y,slope_cr_gy_y,entr_cr_acc_y,entr_cr_gy_y,eng_cr_acc_y,eng_cr_gy_y,cen_cr_acc_y,cen_cr_gy_y,frp_cr_acc_y,frp_cr_gy_y,skew_cr_acc_y,skew_cr_gy_y,kur_cr_acc_y,kur_cr_gy_y,min_th_acc_z,min_th_gy_z,max_th_acc_z,max_th_gy_z,mean_th_acc_z,mean_th_gy_z,var_th_acc_z,var_th_gy_z,aad_th_acc_z,aad_th_gy_z,rms_th_acc_z,rms_th_gy_z,slope_th_acc_z,slope_th_gy_z,entr_th_acc_z,entr_th_gy_z,eng_th_acc_z,eng_th_gy_z,cen_th_acc_z,cen_th_gy_z,frp_th_acc_z,frp_th_gy_z,skew_th_acc_z,skew_th_gy_z,kur_th_acc_z,kur_th_gy_z,min_cr_acc_z,min_cr_gy_z,max_cr_acc_z,max_cr_gy_z,mean_cr_acc_z,mean_cr_gy_z,var_cr_acc_z,var_cr_gy_z,aad_cr_acc_z,aad_cr_gy_z,rms_cr_acc_z,rms_cr_gy_z,slope_cr_acc_z,slope_cr_gy_z,entr_cr_acc_z,entr_cr_gy_z,eng_cr_acc_z,eng_cr_gy_z,cen_cr_acc_z,cen_cr_gy_z,frp_cr_acc_z,frp_cr_gy_z,skew_cr_acc_z,skew_cr_gy_z,kur_cr_acc_z,kur_cr_gy_z,min_ch_acc_x,min_ch_gy_x,max_ch_acc_x,max_ch_gy_x,mean_ch_acc_x,mean_ch_gy_x,var_ch_acc_x,var_ch_gy_x,aad_ch_acc_x,aad_ch_gy_x,rms_ch_acc_x,rms_ch_gy_x,slope_ch_acc_x,slope_ch_gy_x,entr_ch_acc_x,entr_ch_gy_x,eng_ch_acc_x,eng_ch_gy_x,cen_ch_acc_x,cen_ch_gy_x,frp_ch_acc_x,frp_ch_gy_x,skew_ch_acc_x,skew_ch_gy_x,kur_ch_acc_x,kur_ch_gy_x,min_ch_acc_y,min_ch_gy_y,max_ch_acc_y,max_ch_gy_y,mean_ch_acc_y,mean_ch_gy_y,var_ch_acc_y,var_ch_gy_y,aad_ch_acc_y,aad_ch_gy_y,rms_ch_acc_y,rms_ch_gy_y,slope_ch_acc_y,slope_ch_gy_y,entr_ch_acc_y,entr_ch_gy_y,eng_ch_acc_y,eng_ch_gy_y,cen_ch_acc_y,cen_ch_gy_y,frp_ch_acc_y,frp_ch_gy_y,skew_ch_acc_y,skew_ch_gy_y,kur_ch_acc_y,kur_ch_gy_y,min_ch_acc_z,min_ch_gy_z,max_ch_acc_z,max_ch_gy_z,mean_ch_acc_z,mean_ch_gy_z,var_ch_acc_z,var_ch_gy_z,aad_ch_acc_z,aad_ch_gy_z,rms_ch_acc_z,rms_ch_gy_z,slope_ch_acc_z,slope_ch_gy_z,entr_ch_acc_z,entr_ch_gy_z,eng_ch_acc_z,eng_ch_gy_z,cen_ch_acc_z,cen_ch_gy_z,frp_ch_acc_z,frp_ch_gy_z,skew_ch_acc_z,skew_ch_gy_z,kur_ch_acc_z,kur_ch_gy_z)
#replace with bestset from feature selection
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,rms_cr_acc_y, rms_cr_acc_x, mean_cr_acc_x, mean_cr_acc_z, mean_cr_acc_y, rms_cr_acc_z, mean_ch_acc_z, max_cr_acc_z, max_cr_acc_x, max_ch_acc_z, min_ch_acc_z, rms_ch_acc_z, mean_ch_acc_x, rms_ch_acc_x, max_cr_acc_y, min_cr_acc_x, max_th_acc_z, min_cr_acc_y, min_cr_acc_z, entr_cr_acc_z, frp_cr_acc_z, aad_cr_acc_x, rms_cr_gy_y, var_cr_acc_z, aad_cr_acc_z, mean_th_acc_z, min_ch_acc_x, cen_cr_acc_z, eng_cr_acc_z, min_cr_gy_z, slope_ch_gy_y, skew_cr_acc_z, rms_th_acc_z, var_cr_gy_y, aad_cr_gy_y, max_cr_gy_z, var_cr_acc_x, mean_cr_gy_z, frp_cr_acc_x, rms_th_acc_x, min_th_acc_z, slope_cr_acc_x, mean_ch_gy_y, mean_cr_gy_y, cen_ch_acc_z, mean_th_acc_x, aad_cr_gy_z, rms_cr_gy_z, kur_cr_acc_z, slope_ch_acc_z, max_cr_gy_y, aad_cr_acc_y, var_cr_gy_z, entr_cr_acc_x, slope_cr_acc_z, entr_ch_acc_z, var_cr_acc_y, cen_cr_acc_x, aad_ch_acc_z, min_cr_gy_y, slope_cr_acc_y, min_th_acc_y, rms_ch_gy_y, var_ch_acc_z, frp_cr_acc_y, max_ch_acc_x, max_th_acc_x, frp_th_acc_z, entr_cr_acc_y, mean_th_gy_y, var_th_gy_z, rms_cr_gy_x, min_th_gy_y, rms_th_gy_z, entr_th_acc_z, cen_cr_acc_y, aad_cr_gy_x, cen_th_acc_z, slope_ch_acc_x, var_cr_gy_x, aad_ch_acc_x, frp_ch_acc_z, max_th_gy_y, rms_ch_acc_y, min_th_acc_x, var_th_acc_y, max_th_gy_x, entr_cr_gy_y, rms_ch_gy_x, max_th_gy_z, max_th_acc_y, slope_th_acc_z, min_ch_gy_x, var_th_gy_x, min_th_gy_x, rms_ch_gy_z, mean_th_acc_y, var_ch_acc_x, var_ch_gy_x, var_ch_gy_y, max_ch_gy_y, eng_th_acc_y, min_ch_gy_y, aad_ch_gy_y, min_th_gy_z, var_th_gy_y, eng_th_acc_z, aad_th_gy_y, cen_cr_gy_y, var_ch_gy_z, eng_cr_acc_x, frp_cr_gy_y, min_cr_gy_x, frp_th_acc_y, kur_th_acc_z, rms_th_gy_y, eng_ch_acc_z, var_ch_acc_y, skew_th_acc_z, rms_th_gy_x, max_ch_acc_y, eng_cr_acc_y, kur_th_acc_y, aad_th_gy_z, var_th_acc_x, entr_cr_gy_z, cen_cr_gy_z, entr_th_acc_y, cen_ch_gy_y, frp_th_acc_x)
#Data Normilization

c=ncol(mydata)
features=mydata[,4:c]
norfeatures=data.Normalization(features,type="n1",normalization="column")
mydata=data.frame(window=c(1:max(adjwin)),label=wlabel,label_c2=wlabel_c2,norfeatures)
#Check Missing Values
missing=as.data.frame(which(is.na(mydata), arr.ind=TRUE))
#Delete Missing Columns
#mydata=mydata[,-c(17,167,195,197)]
SM_mydata_t1_1=mydata
```
####Get the interested part from the testing dataset of T1_1
```{r}
set.seed(123)
p<- predict(object = c1_model.knn,SM_mydata_t1_1[,-c(1,2,3)])
new_SM_mydata_t1_1=data.frame(SM_mydata_t1_1,c1_p=p)
int_SM_mydata_t1_1=subset.data.frame(new_SM_mydata_t1_1,new_SM_mydata_t1_1$c1_p=="interested")
```
####Test the c2 model on identified interested activities
```{r}
#Test performance of the trained model with Confusion Matrix
set.seed(123)
c2_pre<- predict(c2_nbmodel, int_SM_mydata_t1_1[,-c(1,2,3)],type="class")
c2time_classifying=system.time(c2_pre<- predict(c2_nbmodel, int_SM_mydata_t1_1,type="class"))
c2conf.matrix=confusionMatrix(c2_pre, int_SM_mydata_t1_1$label_c2)
c2acc=c2conf.matrix$overall[1]
```
